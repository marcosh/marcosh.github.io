---
layout: post
title:  "Either why or how"
author: Marco Perone
date: 2021-09-24 08:06:42 +0200
categories: post
tags: php haskell functional
comments: true
pageUrl: '"http://marcosh.github.io/post/2021/09/24/either-why-or-how.html"'
pageIdentifier: '"Either why or how"'
description: "Either why or how"
image: "/img/either.png"
---

`Either` is one of the easiest data structures which can be used to make your code safer and more composable. It is not particularly complex but sometimes it is still hard to grasp, especially for programmers used to a procedural or object oriented approach.

In this post I'll try to give an explanation on the benefits of using the `Either` data structure, both from a theoretical and from a practical point of view. I'll provide examples in `Haskell` and `PHP` with [Psalm](https://psalm.dev/), because these are the languages I know, but the same ideas are easily adaptable to any other programming language.

This post is basically a transcript of an explanation I gave about `Either` to my colleagues at `Soisy`, where we are starting to use extensively `Either` in our `PHP` codebase.

## Let' start from the why

The main reason to introduce `Either`, as many other data structures, in a codebase comes from the desire to make the code satisfy [referential transparency](https://www.wikiwand.com/en/Referential_transparency), which brings a lot of goodies:

- the code is simpler (non necessarily [easier](https://www.infoq.com/presentations/Simple-Made-Easy/)), because there are less moving parts and less communications channels
- the code is easier to reason about, because it has a clear semantic
- the code is easier to test, because we can just check the output is the expected one given a certain input
- the code is easier to refactor
- the code is safer, because less things can happen under the hood
- the code is more composable
- sometimes the code could be made more performant, since we can cache basically any step of our computations

Unfortunately, some things like errors, state management and interaction with the outside world, tend to break referential transparency, with the cost of losing all the above benefits.

Luckily, we can have the cake and eat it, too! The trick is to represent effects like errors, state and IO inside the language, bringing back referential transparency.

## A motivating example

If we think about operations which can fail, like validations and parsing, we can see that they have an input, which is the datum we want to validate or parse, and an output, which can be either a success, containing the desired result, or a failure, containing some information about what failed.

It comes quite natural to model this with a function which takes an input and return either a success or a failure.

```haskell
-- haskell
parse :: input -> Either failure success
```

```php
// php
/**
 * @template Input
 * @template Failure
 * @template Success
 */
interface Parser
{
  /**
   * @param Input
   * @return Either<Failure, Success>
   */
  public function parse($input): Either;
}
```

Once we are able to represent the concept of _something is either this or that_ in our language, we can completely describe a parsing operation, regaining our dear referential transparency.

## Modelling `Either`

Our task now is to model an `Either` data structure. To do this, we need to consider which actually are the requirements that such a structure needs to satisfy.

It might not be completely straightforward, but the requirements which characterize the concept of something which could be `Either` `a` or `b` are the following:

- we need a way to construct `Either a b` starting from an `a`
- we need a way to construct `Either a b` starting from a `b`
- we need to do the above in the _best_ possible way, i.e. as soon as we have a data type `t` which can be constructed from an `a` and can be constructed from a `b`, then we need a way to construct `t` from `Either a b`

We can represent them with a diagram

<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: Coproduct Pages: 1 -->
<svg style="width: 100%" width="204pt" height="188pt" viewBox="0.00 0.00 204.00 188.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 184)">
<title>Coproduct</title>
<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-184 200,-184 200,4 -4,4"></polygon>
<!-- a -->
<g id="node1" class="node">
<title>a</title>
<polygon fill="none" stroke="#000000" points="54,-180 0,-180 0,-144 54,-144 54,-180"></polygon>
<text text-anchor="middle" x="27" y="-157.8" font-family="Courier,monospace" font-size="14.00" fill="#000000">a</text>
</g>
<!-- Either a b -->
<g id="node2" class="node">
<title>Either a b</title>
<polygon fill="none" stroke="#000000" points="147.986,-108 48.014,-108 48.014,-72 147.986,-72 147.986,-108"></polygon>
<text text-anchor="middle" x="98" y="-85.8" font-family="Courier,monospace" font-size="14.00" fill="#000000">Either a b</text>
</g>
<!-- a&#45;&gt;Either a b -->
<g id="edge1" class="edge">
<title>a-&gt;Either a b</title>
<path fill="none" stroke="#000000" d="M44.9163,-143.8314C53.3442,-135.2848 63.541,-124.9443 72.736,-115.6198"></path>
<polygon fill="#000000" stroke="#000000" points="75.3131,-117.9912 79.8425,-108.4133 70.3289,-113.0761 75.3131,-117.9912"></polygon>
</g>
<!-- t -->
<g id="node4" class="node">
<title>t</title>
<polygon fill="none" stroke="#000000" points="125,-36 71,-36 71,0 125,0 125,-36"></polygon>
<text text-anchor="middle" x="98" y="-13.8" font-family="Courier,monospace" font-size="14.00" fill="#000000">t</text>
</g>
<!-- a&#45;&gt;t -->
<g id="edge3" class="edge">
<title>a-&gt;t</title>
<path fill="none" stroke="#000000" d="M17.5532,-143.9434C9.0041,-124.9046 -.4932,-94.5964 12,-72 22.6056,-52.8177 43.194,-39.5309 61.5673,-30.9375"></path>
<polygon fill="#000000" stroke="#000000" points="63.1407,-34.0698 70.9089,-26.8652 60.3433,-27.653 63.1407,-34.0698"></polygon>
</g>
<!-- Either a b&#45;&gt;t -->
<g id="edge5" class="edge">
<title>Either a b-&gt;t</title>
<path fill="none" stroke="#000000" stroke-dasharray="5,2" d="M98,-71.8314C98,-64.131 98,-54.9743 98,-46.4166"></path>
<polygon fill="#000000" stroke="#000000" points="101.5001,-46.4132 98,-36.4133 94.5001,-46.4133 101.5001,-46.4132"></polygon>
</g>
<!-- b -->
<g id="node3" class="node">
<title>b</title>
<polygon fill="none" stroke="#000000" points="196,-180 142,-180 142,-144 196,-144 196,-180"></polygon>
<text text-anchor="middle" x="169" y="-157.8" font-family="Courier,monospace" font-size="14.00" fill="#000000">b</text>
</g>
<!-- b&#45;&gt;Either a b -->
<g id="edge2" class="edge">
<title>b-&gt;Either a b</title>
<path fill="none" stroke="#000000" d="M151.0837,-143.8314C142.6558,-135.2848 132.459,-124.9443 123.264,-115.6198"></path>
<polygon fill="#000000" stroke="#000000" points="125.6711,-113.0761 116.1575,-108.4133 120.6869,-117.9912 125.6711,-113.0761"></polygon>
</g>
<!-- b&#45;&gt;t -->
<g id="edge4" class="edge">
<title>b-&gt;t</title>
<path fill="none" stroke="#000000" d="M178.4468,-143.9434C186.9959,-124.9046 196.4932,-94.5964 184,-72 173.3944,-52.8177 152.806,-39.5309 134.4327,-30.9375"></path>
<polygon fill="#000000" stroke="#000000" points="135.6567,-27.653 125.0911,-26.8652 132.8593,-34.0698 135.6567,-27.653"></polygon>
</g>
</g>
</svg>

If you want to know more why these requirements make sense, take a look at [coproducts](https://en.wikipedia.org/wiki/Coproduct).

Another thing which could help with the intuition of these requirements is to think about them in terms of logic, interpreting `a`, `b` and `t` as propositions and functions as implications (as suggested by the [Curry-Howard correspondence](https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence)). Then the requirements we listed above for `Either` become the [introduction and elimination rules](https://www.reddit.com/r/logic/comments/3p5wjg/overview_of_the_introduction_and_elimination/) for the `or` disjunction operator.

## Translating into code

Translating the above requirements into code is fairly straightforward.

### Haskell

Let's try first in Haskell, where it's easier.

We need to define a type `Either a b` which can be constructed either from an `a` or from a `b`. Hence we define a datatype with two constructors `Left`, which accepts an `a`, and `Right`, which accepts a `b`

```haskell
data Either a b
  = Left a
  | Rigth b
```

This satisfies our first two requirements. For the third one we need a function which receives a function `a -> t` and a function `b -> t` and returns a function `Either a b -> t`. This is exactly what the [`either`](https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#v:either) function does

```haskell
either :: (a -> t) -> (b -> t) -> Either a b -> t
```

### PHP

Now let's try in PHP, where the solution is a little more verbose, but not anymore complicated. First we need the two constructors

```php
/**
 * @template A
 * @template B
 */
class Either
{
  /**
   * @template C
   * @template D
   * @param C $value
   * @return self<C, D>
   */
  public static function left($value): self {...}

  /**
   * @template C
   * @template D
   * @param D $value
   * @return self<C, D>
   */
  public static function right($value): self {...}
}
```

For the third requirement, we need to define a method which receives as input two callables for consuming each of the branches and use them to process the `Either` itself to compute the result

```php
/**
 * @template A
 * @template B
 */
class Either
{
  /**
   * @template T
   * @param callable(A): T $ifLeft
   * @param callable(B): T $ifRight
   * @return T
   */
  public function eval(callable $ifLeft, callable $ifRight) {...}
}
```

For a more complete implementation of `Either` in PHP, take a look at [this](`https://github.com/marcosh/php-validation-dsl/blob/master/src/Result/ValidationResult.php`) or [this](https://github.com/marcosh/lamphpda/blob/master/src/Either.php).

## What can we do with this?

Now it's time to see some example and some concrete benefits of such an approach. Let's see some of the things which come quite easy and natural once we have the `Either` data structure in place.

I'll try to provide some concrete examples all in the context of parsing/validation.

### Forget (temporarily) that we are working with `Either`

Suppose you were able to parse a `User` from some raw data, obtaining an `Either Error User`. Your `User` datatype/class also exposes a function/method to retrieve her date of birth.

```haskell
-- haskell
birthDate :: User -> Date
```

```php
// php
class User
{
  public function birthDate(): DateTimeImmutable {...}
}
```

The function `birthDate` does not know anything about `Either`, so how can we use it when we only have an `Either Error User`? Luckily `Either` allows to lift a function which knows nothing about it to a function which works nicely with it. This is done using the so called `map` combinator

```haskell
-- haskell
fmap birthDate :: Either Error User -> Either Error Date
```

```php
/**
 * @template A
 * @template B
 */
class Either
{
  /**
   * @template C
   * @param callable(B): C $f
   * @return self<A, C>
   */
  public function map(callable $f): self {..}
}

/** @var Either<Error, User> $eitherUser */
$eitherUser;

/** @var Either<Error, DateTimeImmutable> $eitherBirthDate */
$eitherBirthDate = $eitherUser->map([User::class, 'birthDate']);
```

### Join several results

Suppose you have a `User` datatype/class which can be constructed just from a name and a surname

```haskell
-- haskell
data User = User Name Surname
```

```php
// php
class User
{
  public static function user(Name $name, Surname $surname): self {...}
}
```

If you want build a user, you need to first build a `Name` and a `Surname`. Suppose we already have a way to parsing strings to `Name` and `Surname`

```haskell
-- haskell
parseName :: String -> Either Error Name
parseSurname :: String -> Either Error Surname
```

```php
// php
class Name
{
  /**
   * @return Either<Error, self>
   */
  public static function parse(string $s): Either {...}
}

class Surname
{
  /**
   * @return Either<Error, self>
   */
  public static function parse(string $s): Either {...}
}
```

What we would like to do now is to pass the results of the parsing of `Name` and `Surname` to the constructor of `User` but, as in the previous paragraph, our arguments are wrapped in `Either Error` and therefore we can't simply pass them to the constructor.

We're still in luck since `Either` allows to lift a function of any arity (i.e. with any number of arguments) to its context

```haskell
-- haskell
User <$> parseName "Marco" <*> parseSurname "Perone" :: Either Error User
```

```php
// php
/**
 * @template A
 * @template B
 */
class Either
{
  public static function liftA(callable $f, self ...$args): self {..}
}

/** @var Either<Error, User> $eitherUser */
$eitherUser = Either::liftA(
  [User::class, 'user'],
  Name::parse('Marco'),
  Surname::parse('Perone')
);
```

The difference in the implementation between Haskell and PHP is due to the fact that in Haskell every function is curried by default, which makes it easier to use simpler operators.

#### What happens to the errors?

The code above looks nice, but there is a subtle thing which is not clear. Try to think about the case when both the parsing of the name and the parsing of the surname failed. What should be the final error? Should we stop the computation as soon as one piece of the puzzle fails? Or should we collect and report all the errors?

There is not correct answer here, it really depends on the context and on the situation. so we need to make space for both options.

Haskell by default stops as soon as it finds one error and reports just that one. If you want to collect all the errors, you should use [`Validation`](https://hackage.haskell.org/package/either/docs/Data-Either-Validation.html#t:Validation) instead. As a datatype its definition is not different than the `Either` one. The main thing which changes is the [`Applicative`](https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative) instance, allowing us to collect errors. Notice that the instance requires a `Semigroup` constraint on `Error`, which allows us to accumulate the errors themselves.

In PHP the most reasonable thing to do is to modify the `liftA` implementation, adding a parameter which specifies how to behave when we have more than one error

```php
// php
/**
 * @template A
 * @template B
 */
class Either
{
  /**
   * @param callable(A, A): A $joinLeft
   */
  public static function liftA(callable $joinLefts, callable $f, self ...$args): self {..}
}
```

### Sequencing operation which may fail

It's often the case that a parsing operation does not happen in a single step; more often it is composed by several steps, each one depending on the result of the previous one.

Let's consider the case when we want to parse a `User` from the body of an HTTP request containing some JSON. We could split the whole operation into three steps:

- parse the request's body into `JSON`
- parse the `JSON` into some raw `UserData`
- parse the raw `UserData` into the domain `User` datatype/object

```haskell
-- haskell
parseJSON :: String -> Either Error JSON
parseUserData :: JSON -> Either Error UserData
parseUser :: UserData -> Either Error User
```

```php
class JSON
{
  /**
   * @return Either<Error, self>
   */
  public static function fromString(string $s): Either {...}
}

class UserData
{
  /**
   * @return Either<Error, self>
   */
  public static function fromJSON(JSON $json): Either {...}
}

class User
{
  /**
   * @return Either<Error, self>
   */
  public static function fromUserData(UserData $data): Either {...}
}
```

We clearly need to run the three steps in sequence, every time passing the result of the previous step to the next one. As always `Either` allows to implement this behaviour in a very declarative manner

```haskell
-- haskell
parseJSON >=> parseUserData >=> parseUser :: String -> Either Error User
```

```php
/** @var string $responseBody */
$responseBody;

JSON::fromString($responseBody)
  ->bind([UserData::class, 'fromJSON'])
  ->bind([User::class, 'fromUserData'])
```

The name `bind` is the classical one, it might come easier to read it as `andThen`.

The difference in the implementation here is due to object orientation. The signature of the `>=>` operator is

```haskell
(>=>) :: (a -> Either e b) -> (b -> Either e c) -> a -> Either e c
```

As you can see it has only functions as inputs. This prevents it to implementing it as a concrete method of a class. A completely equivalent formulation of `>=>` is

```haskell
bind :: Either e a -> (a -> Either e b) -> Either a b
```

Its first argument is a concrete datatype and therefore we can implement it as a method of the `Either` class.

## Conclusion

`Either` is a data structure which allows describing in a single datatype/class the fact that something could be either one of two things. This turns out to be very helpful also in domain modelling, when a single concept could have different instances.

`Either` particularly shines when it is used to represent the result of a computation which might fail. This allows us in the first place to gain all the benefits which referential transparency offers. Moreover, it allows to create a very expressive API which leads to a very declarative style of programming.

As a data structure `Either` is much more used in functional languages, but it could be used with great advantage in any language which offers higher order functions and type variables/generics.

If you hadn't already, I'd encourage you to try to use it in your code base. Once you do, it's hard you'll want to go back.
